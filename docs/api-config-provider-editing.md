# API 配置 / 提供商编辑与选择：行为契约说明

本文档描述“API 配置编辑 / 提供商编辑 / 模型选择”在前后端的关键契约，重点覆盖 **掩码显示、保留旧值、清空删除** 等容易产生心智偏差的边界情况。

## 1. Vendor API Key 的三态与保存语义（强约定）

### 1.1 前端展示语义
- **空字符串**：未配置（或已清除）。
- **`***`（或全 `*`）**：已配置，但明文被安全隐藏（前端不应尝试展示明文）。
- **其他字符串**：明文 key（仅用于非内置供应商；内置供应商永远不返回明文）。

### 1.2 `save_vendor_configs` 的输入语义（后端）
- **`api_key = "***"` 或全 `*`**：表示“保留不变”（不改动安全存储中的值）。
- **`api_key = ""`（空字符串）**：表示“明确清空”。
  - 内置供应商：会删除 `{vendor_id}.api_key`（以及 SiliconFlow 的兼容旧键 `siliconflow.api_key`）。
  - 非内置供应商：会把 key 清空并保存（加密存储）。
- **其他非空字符串**：表示“设置为该值”。

## 2. 内置供应商的 key 存储位置
- 内置供应商使用键名：`{vendor_id}.api_key`（例如 `builtin-deepseek.api_key`）。
- 该类键被识别为敏感数据并进入安全存储（加密文件存储），避免明文落入 SQLite settings。

## 3. `get_vendor_configs` 的返回语义（掩码一致性）
- 无论内置供应商是否已存在于 `vendor_configs`，后端都会根据安全存储是否存在 key 返回：
  - 存在：`api_key = "***"`
  - 不存在：`api_key = ""`

## 4. baseUrl 的编辑保存时机（前端）
- 提供商详情页的 baseUrl 输入采用 **本地草稿 + 失焦保存**（onBlur）。
- 目的：避免“每键即保存”导致的并发乱序覆盖、输入卡顿与最终值不一致。

## 5. 模型列表与 enabled 的单一事实来源
- 前端需要以 **后端 `get_api_configurations`** 的返回为准（后端会综合 vendor/profile 与 key 是否存在计算 `enabled`）。
- 避免在前端用 `***` 掩码 key 进行“是否配置”的推断，从而误判内置供应商不可用。

